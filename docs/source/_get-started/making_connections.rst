Connecting Nodes
================

Building a Connection
---------------------

..
    **# TODO: Connect function and class based nodes**

The strength of the ZnTrack package is within connecting nodes.
This is easily done by passing one Node as an argument to another one.

Let us assume two Nodes ``GenerateData`` and ``ProcessData``.
We can connect these Nodes as follows:

.. code-block:: python

    generate_data = GenerateData(**kwargs)
    process_data = ProcessData(data=generate_data)

Now, the ``process_data.data`` attribute will be the loaded instance of ``GenerateData``, when running ``dvc repro``.
The following connection has been established:

.. image:: https://mermaid.ink/img/pako:eNptzjELwjAQBeC_Ut7cDnXM4FRwFXTzOhzJ1RaaRNILIqX_3VRcBN908D64t8JGJzAY5vi0Iyetrh2F6ptQyvZGOEmQxCodKxP6X3Ao4JyilWX527dNc_w41PCSPE-uPFx3RNBRvBBMOZ0MnGclUNgK5azx8goWRlOWGvnh9gUT3xN7mIHnRbY3T449Ig?type=png
    :alt: mermaid diagram

In some cases it is useful to connect Node attributes instead of Nodes.
In the above example the Node ``ProcessData`` has to know the correct attributes of ``GenerateData`` to e.g. access the ``data`` attribute.
Therefore, one can also connect attributes of Nodes.
This is done by appending ``@`` and the attribute name to the Node.
With this, any attribute of any Node can be connected.

.. code-block:: python

    generate_data = GenerateData(**kwargs)
    process_data = ProcessData(data=generate_data @ "data")

.. tip::
    In a Future release of ZnTrack it will be possible to connect Nodes directly inside a Context Manager.
    The current API will still remain but it can be worth looking for updates of the ZnTrack package.
    Check out `ZnFlow <https://github.com/zincware/znflow>`_ for a preview and further information.

    .. code-block:: python

        with zntrack.DiGraph() as graph:
            generate_data = GenerateData(**kwargs)
            process_data = ProcessData(data=generate_data.data)

Write documentation
-------------------
ZnTrack Nodes are designed to be flexible and easy to connect.
This is achieved through the concept of `duck typing <https://en.wikipedia.org/wiki/Duck_typing>`_, which allows Nodes to be connected as long as they have the correct attributes and methods.
To help document the required attributes and methods, we suggest using the ``typing.Protocol`` module.

For example, consider the Node ``ProcessData``, which expects an attribute ``data`` of type ``np.ndarray``.
We can define such a ``typing.Protocol`` as follows:

.. code-block:: python

    import typing
    import numpy as np

    class HasData(typing.Protocol):
        """Protocol for Nodes with data attribute"""
        data: np.ndarray

Then, we can use this ``HasData` protocol as a type hint for the ``input_data`` attribute of the ``ProcessData`` Node:

.. code-block:: python

    from zntrack import Node, zn

    class ProcessData(Node):
        input_data: HasData = zn.deps()

        def run(self):
            """Do something with 'self.input_data.data'."""
            print(self.input_data.data.shape)


This highlights, that the ``ProcessData`` Node should work with any Node that has a ``data`` attribute of type ``np.ndarray``, whether it is a NumPy array generated by another Node from the same package, or generated by a Node from an entirely different library.
For a single attribute one could also expect ``np.ndarray`` as type hint directly.
But e.g. if more than one attribute is required, it is feasible to define a ``typing.Protocol``.