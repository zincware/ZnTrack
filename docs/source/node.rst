.. _node:

Node
====

A :term:`Node` is the core component of ZnTrack, defining a unit of computation to be used in a workflow.
It encapsulates a self-contained piece of logic that can be executed independently or as part of a larger pipeline.


.. note::

    The :term:`Node` is built on top of Python's `dataclasses <https://docs.python.org/3/library/dataclasses.html>`_,
    leveraging their simplicity and power to define structured, reusable components.

A :term:`Node` consists of the following three key parts:

Inputs
------
Every parameter or dependency required to run the :term:`Node`.
Inputs define the data or configuration that the :term:`Node` needs to perform its computation.
Possible inputs are:

* :meth:`zntrack.params` for json-serializable data, e.g. ``{"loss": "mse", "epochs": 10}``.
* :meth:`zntrack.params_path` for parameter files. See `parameter dependencies <https://dvc.org/doc/user-guide/pipelines/defining-pipelines#parameter-dependencies>`_ for more information.
* :meth:`zntrack.deps` for dependencies from another :term:`Node`. More details are provided in the  :ref:`Project` section.
* :meth:`zntrack.deps_path` for file dependencies. See `simple dependencies <https://dvc.org/doc/user-guide/pipelines/defining-pipelines#simple-dependencies>`_ for more information.

Outputs
-------
Every result produced by the :term:`Node`.
Outputs are the data or artifacts generated after the :term:`Node` has executed its logic.
Possible outputs are:

* :meth:`zntrack.outs` for any output data. This uses JSON and `pickle <https://docs.python.org/3/library/pickle.html>`_ to serialize data.
* :meth:`zntrack.outs_path` to define an output file path.
* :meth:`zntrack.metrics` for metrics stored as ``dict[str, int|float]``.
* :meth:`zntrack.metrics_path` for file paths to store `metrics <https://dvc.org/doc/command-reference/metrics>`_.
* :meth:`zntrack.plots` for plots as pandas dataframes.
* :meth:`zntrack.plots_path` for file paths to store `plots <https://dvc.org/doc/user-guide/experiment-management/visualizing-plots>`_.

Run
---
The function that is executed when the :term:`Node` is run.
This is where the core computation or logic of the :term:`Node` is defined.

It is also possible to define multiple run methods for a single :term:`Node`.
This allows for flexible execution strategies depending on the context.
For more details, see :ref:`zntrack_apply`.


Example
-------
We can leverage the integrated features of ZnTrack to hide all file writing or reading.

.. code-block:: python

    import zntrack

    class Add(zntrack.Node): # inherit from zntrack.Node
        # we define a parameter as similar to dataclass.Field.
        a: int = zntrack.params()
        # One could use a dict or define as many parameters as needed.
        b: int = zntrack.params()

        # We define an arbitrary output.
        result: int = zntrack.outs()

        def run(self) -> None:
            # The core computation of the Node.
            self.result = self.a + self.b


The :term:`Node` above can also be written like the following :term:`Node`, saving and loading the inputs and outputs manually.

.. tip::

    ZnTrack provides an :term:`nwd` path that is specific to each :term:`Node` in the workflow.
    It is highly recommended to use this path to store all data generated by the :term:`Node` to avoid file name conflicts.

.. code-block:: python

    from pathlib import Path

    class AddViaFile(zntrack.Node):
        params_file: str = zntrack.params_path()

        results_file: Path = zntrack.outs_path(zntrack.nwd / "results.json")

        def run(self) -> None:
            import json

            with open(self.params_file, "r") as f:
                params = json.load(f)

            result = params[self.name]["a"] + params[self.name]["b"]

            self.results_file.parent.mkdir(parents=True, exist_ok=True)
            with open(self.results_file, "w") as f:
                json.dump({"result": result}, f)
